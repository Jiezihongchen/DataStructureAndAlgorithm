# 一个模型三个特征

把动态规划适合解决的问题的模型定义为<u>**多阶段决策最优解模型**</u>。结局问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态，然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

DP的本质是**<u>递归</u>**加**<u>记忆</u>**。

三个特征分别指<u>**最优子结构**</u>，<u>**无后效性**</u>和<u>**重复子问题**</u>。

1. 最优子结构：问题的最优解包含子问题的最优解。反过来说就是可以通过子问题的最优解推导出问题的最优解。
2. 无后效性：两层含义。第一层含义是指在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是指某阶段状态一旦确定，就不受之后阶段的决策影响。
3. 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

<u>**动态规划和分治算法有着明显的区分**</u>。分治算法要求分割成的子问题不能有重复子问题，而动态规划正好相反。分治法解决的问题不一定是最优化问题，但动态规划解决的问题一定是最优化问题。

<u>**贪心和动态规划都要求原问题必须拥有最优子结构**</u>。贪心算法不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题直接被抛弃，因此整个过程以一种单链的流水方式进行。动态规划是从边界开始向上得到目标问题的解，总是会考虑所有子问题。

使用<u>**递推写法**</u>的计算方式是<u>**自底向上**</u>（Bottom-up Approach），使用<u>**递归写法**</u>的计算方式是<u>**自顶向下**</u>（Top-down approach）。

------

# 数塔问题

------

# 最大连续子序列和

------

# 最长不下降子序列(LIS)

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main() {
    int n, nums[255], dp[255] = {1}, ans = 0;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> nums[i];
    for (int i = 1; i < n; i++)
        for (int j = 0; j < i; j++) {
            if (nums[i] >= nums[j]) dp[i] = max(dp[j] + 1, dp[i]);
            ans = max(dp[i], ans);
        }
    cout << ans << endl;
    return 0;
}
```

------

# 最长公共子序列(LCS)

------

# 最长回文子串

------

# 背包问题

## 1. 01背包问题

## 2. 完全背包问题