# 一个模型三个特征

把动态规划适合解决的问题的模型定义为<u>**多阶段决策最优解模型**</u>。结局问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态，然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

三个特征分别指<u>**最优子结构**</u>，<u>**无后效性**</u>和<u>**重复子问题**</u>。

1. 最优子结构：问题的最优解包含子问题的最优解。反过来说就是可以通过子问题的最优解推导出问题的最优解。
2. 无后效性：两层含义。第一层含义是指在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是指某阶段状态一旦确定，就不受之后阶段的决策影响。
3. 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

两种解题思路：<u>**状态转移表法**</u>和<u>**状态转移方程法**</u>。

状态转移表法：回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-翻译代码

状态转移方程法：找最优子结构-写状态转移方程-翻译代码

<u>**动态规划和分治算法有着明显的区分**</u>。分治算法要求分割成的子问题不能有重复子问题，而动态规划正好相反。

------

# 数塔问题

------

# 最大连续子序列和

------

# 最长不下降子序列(LIS)

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main() {
    int n, nums[255], dp[255] = {1}, ans = 0;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> nums[i];
    for (int i = 1; i < n; i++)
        for (int j = 0; j < i; j++) {
            if (nums[i] >= nums[j]) dp[i] = max(dp[j] + 1, dp[i]);
            ans = max(dp[i], ans);
        }
    cout << ans << endl;
    return 0;
}
```

------

# 最长公共子序列(LCS)

------

# 最长回文子串

------

# 背包问题

## 1. 01背包问题

## 2. 完全背包问题