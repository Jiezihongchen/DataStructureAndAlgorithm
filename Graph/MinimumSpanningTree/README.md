最小生成树（Minimum Spanning Tree，MST）是在一个给定的<u>**无向图**</u>G中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自图G的边，并且满足整棵树的边权之和最小。

<u>**最小生成树有3个性质**</u>：

1. 最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。
2. 对给定的图，最小生成树可以不唯一，但边权之和一定是唯一的。
3. 由于最小生成树是在无向图上生成的，因此根结点可以是这棵树上的任意一个结点。

# Prim算法

<u>**基本思想**</u>：对图设置集合S来存放已被访问的顶点，然后执行n次操作：

1. 每次从集合V-S中选择与集合S最近的一个顶点（记为u），访问u并将其加入集合S，同时把这条离集合S最近的边加入最小生成树中
2. 令顶点u作为集合S与集合V-S连接的接口，优化从u能到达的未访问顶点V与集合S的最短距离。

<u>**Prim算法和Dijstra算法使用的思想几乎完全相同**</u>，只有在数组d[]的含义上有所区别。在Dijstra算法中的含义是起点S到顶点V的最短距离，而在prim算法中指的是顶点V和集合S的最短距离。

```c++
Prim(G, d[]) {
	初始化
	for (循环n次) {
		u = 使d[u]最小的还未被访问的顶点的标号
		vis[u] = true
		for (从u出发能达到的所有顶点v) {
			if (v未被访问 and 以u为中介点使得v与集合S的最短距离d[v]更优)
				将G[u][v]赋值给v与集合S的最短距离d[v]
		}
	}
}
```

------

# Kruskal算法

和prime算法不同，kruskal算法采用了<u>**边贪心**</u>的策略。

<u>**基本思想**</u>：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后：

1. 对所有边按边权从小到大进行排序。
2. 按边权从小到大测试所有边，如果当前测试所连接的两个顶点不在同一个连通块，则把这条测试边加入当前最小生成树中；否则，将边舍弃。
3. 执行步骤2，直到最小生成树中的边数等于总顶点数减1或测试完所有边时结束。当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通

<u>**简单概括**</u>：每次选择图中最小边权的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树中。

```c++
int kruskal() {
    令最小生成树的边权之和为ans、最小生成树的当前边数为Num_Edge
    将所有边按边权从小到大排序
    for (从小到大枚举所有边) {
        if (当前测试变的两个端点在不同的连通块中) {
            将该测试边加入最小生成树中
            ans += 测试边的边权
            最小生成树的当前边数Num_Edge + 1
            当边数Num_Edge等于顶点数减1时结束循环
        }
    }
    return ans;
}
```

```c++
struct edge {
    int u, v;
    int cost;
}E[MAXE];
bool cmp(edge a, edge b) {
    return a.cost < b.cost;
}
int kruskal(int n, int m) {
    int ans = 0, Num_Edge = 0;
    for (int i = 1; i <= n; i++) {
        father[i] = i;
    }
    sort(E, E + m, cmp);
    for (int i = 0; i < m; i++) {
        int faU = findFather(E[i].u);
        int faV = findFather(E[i].v);
        if (faU != faV) {
            father[faU] = faV;
            ans += E[i].cost;
            Num_Edge++;
            if (Num_Edge == n - 1) 
                break;
        }
    }
    if (Num_Edge != n - 1)
        return -1;
    else 
        return ans;
}
```

kruskal算法的时间复杂度主要来源于对边进行排序，因此时间复杂度是O(ElogE)。kruskal适合顶点数多，边数少的情况。Dijstra算法的时间复杂度是O(V^2)，通过优化可以到O(VlogV + E)。如果是<u>**稠密图**</u>（边多），用prim算法，如果是<u>**稀疏图**</u>（边少），用kruskal算法。